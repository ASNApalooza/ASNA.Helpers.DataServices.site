<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="favicon.ico">

    <title>Walter</title>

    <!-- Bootstrap core CSS -->
    <!-- <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css"> -->
    <link href="public/vendor/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="public/css/index.css" rel="stylesheet">
    <link href="public/css/prettify.css" rel="stylesheet">
    <link href="public/magnific-popup/magnific-popup.css" rel="stylesheet">
    <link href="public/vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" >
    <link href="public/css/BootStrap01.css" rel="stylesheet" >

    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>

.content {padding-top: 80px ;padding-bottom: 20px}

@media (min-width:768px){
  #components .list-group {position: fixed; width:18%;}
}

@media (min-width:1024px){
  #components .list-group {position: fixed; width:18%;}
}

@media (min-width:1400px){
  #components .list-group {position: fixed; width:14%;}
}

@media (min-width:1920px){
  #components .list-group {position: fixed; width:14%;}
}
    </style>

  </head>

  <body>

    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <!-- <a class="navbar-brand" href="#">Home</a> -->
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav" id="tabs">
            <!-- <li><a href="#components" data-toggle="tab">Documentation</a></li> -->
            <!-- <li><a href="#about" data-toggle="tab">About</a></li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="content container tab-content">

      <!-- <div class="tab-pane" id="home"> -->
<!--         <div class="jumbotron">
          <h1>Some Framework</h1>
          <p>This is a template for a documentation website for a programming framework or library. It includes a template for components description with a navigation list.</p>
          <p><a href="#" class="btn btn-primary btn-lg" role="button">Download &darr;</a></p>
        </div>
 -->

      <!-- </div> -->

      <div class="tab-pane active" id="components">
        <div class="row">
          <div class="col-sm-3">
            <div class="list-group">
              <a href="#qf-overview" class="list-group-item">Overview</a>
              <a href="#qf-query-tester" class="list-group-item">Query Tester</a>
              <a href="#qf-walter-web" class="list-group-item">Walter Web Example</a>
              <a href="#qf-walter-windows" class="list-group-item">Walter Windows Example</a>
              <a href="#qf-export-to-datatable" class="list-group-item">Export to DataTable</a>
              <a href="#qf-excel-to-file" class="list-group-item">Export to Excel file</a>
              <a href="#qf-export-to-json" class="list-group-item">Export to Json</a>
              <a href="#qf-export-to-listitem" class="list-group-item">Export to ListItem array</a>
              <a href="#qf-jquery-autocomplete" class="list-group-item">jQuery AutoComplete</a>
              <a href="#qf-jquery-datatable" class="list-group-item">jQuery DataTable</a>
              <a href="#qf-query-syntax" class="list-group-item">Walter Query Syntax</a>


            </div>
          </div><!-- /.col-sm-3 -->

          <div class="col-sm-9">
            <div class="clearfix">
               <h1>What is Walter?</h1>
              <!-- <div class="col-sm-3"> -->
                <div class="pull-left thumbnail  space-right">
                  <img src="public/images/walter.png"/>
                  <div class="text-center">
                    <a class="black" href="http://www.joshuabudich.com/"><small>Image by Joshua Budich</small></a>
                  </div>
                </div>
              <!-- </div> -->
              <!-- <div class="col-sm-9"> -->
                <p class="lead">In the Big Lebowski, Walter Sobchak was The Dude's faithful sidekick. This library
                is intended to be a faithful sidekick for your AVR projects. Walter's specialty is in executing 
                dynamic, declarative queries that produce read-only lists in a variety of formats for your AVR for .NET 
                applications.</p>
                <p class="lead">Let's see what Walter can do for you.
            </div>

<!-- Begin: qf_overview.html -->
            <div id="qf-overview" class="content section">
              <h2>Walter overview</h2>
                <p>Walter is a component that performs dynamic read-only queries against DataGate databases. It works against physical and logical files. While Walter is intended primarily for ASNA Visual RPG, it would also work just fine with VB.NET or C#. 

                <p>Walter implements a declarative programming model that makes is easy to fetch dynamic query results with a minimal of effort and with high performance. When used against the IBM i, Walter consistently produces output with
                subsecond response times (usually less than 250 milliseconds). It takes about 1-15 lines of code to configure Walter and produce output with it. Part of the reason I wrote Walter is that I got tired of needing to create an endless supply of custom classes for reading data and producing that data in a variety of formats.</p>

                <p>Some of Walter's design goals are:
                <ul>
                <li>Allow runtime configuration of queries, including library, file, fields, selection criteria, and sort
                order with a declarative, logic-free syntax. You only need to tell Walter what you want, you don't need
                tell how it how to get it.</li>
                <li>Provide dynamic, performant query capabilities independent of the availability of explicit access paths 
                provided by logical files. Walter works with the local ASNA DataBase, but really shines when used with the 
                IBM i. On the IBM i, Walter puts OpenQueryFile to good use. Walter also works with ASNA's DataGate for 
                SQL Server, but has been tested the least there so far.</li>
                <li>Provide built-in, key-driven paging support. When used against logical files with a known key 
                structure, Walter provides built in forward paging. You don't have to manage "next" key values and Walter
                tells you when the last page has been read.</li>  
                <li>Support several standard output types but also provide an plug-in model so that additional output
                types can easily be added later. Walter's default output type is a System.Data.DataTable, but it includes
                output adapters to produce an array of ListItems (for populating drop-down lists in Windows and Web
                applications), Excel spreadsheets (in native XLSX format), and Json for client-side JavaScript use. </li>
                <li>Allow a common way to pass query meta data into Walter's output adapters. This allows each output
                adapter a measure of customization. For example, Walter's Excel output adapter uses this meta data 
                to provide a spreadsheet heading and the worksheet name.</li>
                <li>Provide robust error handling so trouble-shooting is easy.</li>
                <li>Allow for the easy aliasing of field names so that, for example, when producing an Excel spreadsheet
                user-friendly column names are available.</li> 
                <li>Be usable by any .NET application type. Walter works with Windows, ASP.NET and Web services and can be coded
                in AVR, VB.NET, C# or even JavaScript. Walter makes a great partner for extending ASNA Wings, Monarch and 
                even Mobile RPG applications. Walter can be used directly to create department-level projects or it can be used as a primitive in the creation of more robust database repository class libraries (where it could be tapped to produce lists for those libaries). Walter has a sister project, ASNA.Helpers.ASPNET that provides helper facilities
                for using Walter in ASP.NET applications.</li>
                <li>Provide an interactive query tester for creating and testing queries and generating the AVR, C#, or even
                JavaScript. </li>
                <li>Be formally open sourced so that others can easily extend, enhance, and bugfix Walter.</li>
                </ul>
                </p>

                <h3>Output adapters</h3>
                <p>Walter's query output is driven by output adapters. The default output adapter emits query output as a DataTable. The DataTable can be bound to most Windows and ASP.NET controls (including Windows' DataGridView and ASP.NET's GridView). Walter also includes output adapters to emit query results as: </p>

                <ul class="task-list">
                <li><strong>Json</strong>. Walter's Json output can be used in a variety of ways including feeding a JavaScript autocomplete widget (such as jQuery UI's <a href="http://jqueryui.com/autocomplete/">AutoComplete</a>) or feeding a client grid such as the jQuery DataTable grid. Walter includes an HTTP handler to make its Json output easy to use with ASP.NET. A small JavaScript wrapper for the jQuery UI AutoComplete widget is included. Using Walter and its components make it very easy to add AutoComplete to your ASP.NET pages (including Wings and Monarch pages). </li>
                <li><strong>Excel</strong>. Walter's Excel adapter produces Excel spreadsheets (in XLSX format) on either Windows Web servers or Windows clients, without needing Excel installed. This adapter uses the <a href="https://closedxml.codeplex.com/">ClosedXML</a> library (which itself is a wrapper around Microsoft's <a href="http://msdn.microsoft.com/en-us/library/office/bb448854(v=office.15).aspx">Open XML SDK)</a>.<br>
                </li>
                <li><strong>ListItem array</strong>. This adapter produces a ListItem array for populating ASP.NET's DropDownList controls or Windows's ComboBox. </li>
                </ul>
                <p></p><p>Should you need some other output type, it's easy to write your own output adapters by implementing a simple interface that Walter provides.</p>
                <p>Before you dig deeply into Walter's technical details, take a look at the next three sections. They feature three example programs of Walter in action. These examples include a Windows-based query tester for Walter, a browser-based example, and a Windows-based example. 
                
                <div class="alert alert-info text-center">
                 <p>Walter was written with AVR 11.2, Visual Studio 2012, and .NET 4.5. You'll need these versions to use Walter without any additional effort. For at least AVR 10.2, you should be able start an empty project and use Visual Studio's 'Add existing item' feature to pull Walter source files into that project to build your own AVR 10.2 version. For AVR 12.0 users, Walter should simply open and compile. Walter will soon be officially ported to AVR 12.0.</p>
                 <p>
                 </p>
                </div>

                <hr>
            </div>
<!-- End: qf_overview.html -->
<!-- Begin: qf-query-tester.html -->
            <div id="qf-query-tester" class="content section">
              <h2>Walter Query Tester</h2>
                <p>The Query Tester is a Windows program that you can use to interactively create and test Walter queries. With a query defined, you can see its various outputs and the code (in either AVR, C#, or JavaScript) that you can copy to put the query in your appliation. The Query Test limits query parameters, order by fields, and query options to three each. This is a Query Tester limitation&mdash;Walter allows as many of each as you need.</p>
                <p>Beyond creating and testing queries, the Query Tester also shows you the AVR (or C#) you need to paste into your application to reproduce the current query. The Query Tester is isn't intended to be an end-user application. Rather, it is aimed at programmers to create and test queries--and optionally generate the AVR needed to programmatically reproduce the query.</p>

    <div class="html-code grid-of-images">
      <div class="query-test-screen-shots-popup-gallery">

        <div>
        <a href="public/images/Walter-query-entry-screen.png" 
           title="Fig 1. Query definition" data-detail="Enter your query here.">
           <img src="public/images/Walter-query-entry-screen.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-query-results-as-datatable.png" 
           title="Fig 2. Query results as a datatable" data-detail="Note the 'next page' link. Walter has automatic paging.">
           <img src="public/images/Walter-query-results-as-datatable.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-query-args.png"
           title="Fig 3. Query arguements" data-detail="Query meta data is available as Json--mostly for diagnostic and debugging purposes.">
           <img src="public/images/Walter-query-args.png" width="200" height="150" />
        </a>
        </div>

        <div>
        <a href="public/images/Walter-query-results-as-json.png" 
           title="Fig 4. Query results as Json" data-detail="The Json data includes 'list' array or query results and query meta data.">
           <img src="public/images/Walter-query-results-as-json.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-AVR-query-code.png" 
           title="Fig 5. AVR cut-and-paste datatable code for the query" data-detail="AVR code to create a datatable with the query. ">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-AVR-json-code.png" 
           title="Fig 6. AVR cut-and-paste Json code for the query" data-detail="AVR code to create Json with the query.">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        </div>        

        <div>
        <a href="public/images/Walter-avr-to-excel-windows-code.png" 
           title="Fig 7. AVR cut-and-paste Excel-for-Windows code for the query" data-detail="AVR code to create an Excel spreadsheet for a Windows app the query.">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-avr-to-excel-web-code.png" 
           title="Fig 8. AVR cut-and-paste Excel-for-Web for the query" data-detail="AVR code to create an Excel spreadsheet for a Web app the query..">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-avr-to-listitem-code.png" 
           title="Fig 9. AVR cut-and-paste ListItem array code for the query" data-detail="AVR code to create an array of ListItems with the query.">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        </div>

        <div>       
        <a href="public/images/Walter-cs-datatable-code.png" 
           title="Fig 10. C# cut-and-paste datatable code for the query" data-detail="C# code to create a datatable with the query.">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-javascript-json-code.png" 
           title="Fig 11. Javascript cut-and-paste code for the query" data-detail="JavaScript code to create Json with a query on the client side.">
           <img src="public/images/Walter-AVR-query-code.png" width="200" height="150" />
        </a>
        <a href="public/images/Walter-query-results-as-excel.png" 
           title="Fig 12. Query results as Excel" data-detail="Use 'View->Show query as Excel' to show the query as an Excel spreadsheet.">
           <img src="public/images/Walter-query-results-as-excel.png" width="200" height="150" />
        </a>
        </div>
    
      </div>
    </div>


<div>
<h3>Figure details</h3>
  <ul>
    <li><strong>Fig 1. Query definition</strong>. <p>This is the query definition panel. Enter the parameters for a query here. Although the query tester only allows three each of query parameters, order-by fields, and query options, Walter's API allows an unlimited number of them. Walter lets you save and then later open query definitions to your local drive.</p>
<p>The DB Name prompt enumerates the ASNA DataGate database names on your PC. At least one database name must be present for the Query Tester to work.</p>
    </li>
    <li><strong>Fig 2. Query results as a datatable</strong>. This shows the query results as a datatable. Note the "Next page" link in the upper right-hand corner. Walter provides built-in "next page" support for paged queries.
    </li>
    <li><strong>Fig 3. Query arguements</strong>. In addition to returning the query results, Walter also returns a Json structure that provides meta data about the query. This data includes the query input arguments, its output arguments, and error info. All of these values are surfaced as properties of the Walter query object. These values are surfaced as a Json object for diagnostic and debugging purposes.
    </li>
    <li><strong>Fig 4. Query results as Json</strong>. This shows the query result as Json. The pure query results are in the "list" array of objects. The other values (resultRowCount, milliseconds, etc) are meta data about the query.
    </li>
    <li><strong>Fig 5. AVR cut-and-paste datatable code for the query</strong>. The code tabs provide the code you need to add the query you defined to your AVR application. The code presented reflects the current definition of the query (that is, this code is dynamically generated every time you tweak the query). Figure 5 shows the AVR code to produce a datatable from your query.
    </li>
    <li><strong>Fig 6. AVR cut-and-paste Json code for the query</strong>. The AVR code to produce Json from your query.
    </li>
    <li><strong>Fig 7. AVR cut-and-paste Excel-for-Windows code for the query</strong>. The AVR code to produce an Excel spreadsheet for Windows applications from your query.
    </li>
    <li><strong>Fig 8. AVR cut-and-paste Excel-for-Web for the query</strong>. The AVR code to produce an Excel spreadsheet for ASP.NET applications from your query.
    </li>
    <li><strong>Fig 9. AVR cut-and-paste ListItem array code for the query</strong>. The AVR code to produce an array of ListItems from your query. This is intended primarily for populating dropdown boxes in either Windows or Web applications (although the ListItem is an object belonging to the ASP.NET namespace domain, it works fine in Windows apps--it's just a data structure.) You can use this 
    </li>
    <li><strong>Fig 10. C# cut-and-paste datatable code for the query</strong>. Walter is an API, it doesn't use any AVR-specific components. For the five types of AVR code shown, the C# equivalent is also available. While not provided, you could also use Walter with VB.NET. (As an aside, Walter's Query Tester was written in C#--as an exercise in using Walter with C#). 
    </li>
    <li><strong>Fig 11. Javascript cut-and-paste code for the query</strong>. Walter provides a JavaScript interface to enable using Walter queries from the client side of ASP.NET applications. When used from JavaScript, Walter can only produce Json output. Figure 11 shows example JavaScript you'd use to use a Walter query from the client side. The JavaScript code preview is the <em>only</em> Code tab that doesn't dynamically represent the current query definition. (Fixing this is on my to-do list!).
    </li>
    </li>
    <li><strong>Fig 12. Query results as Excel</strong>. Figures 7 and 8 show the code to produce an Excel spreadsheet from a Walter query. Use the QueryTester's View->Show query as Excel to show the spreadsheet Walter produces. The spreadsheet produced isn't a static example, it is produced at runtime from the current query definition. 
    </li>
  </ul>
</div>

<div class="you-tube-videos">
<iframe class="youtube-player" type="text/html" width="640" height="385" src="http://www.youtube.com/embed/lrcc1EMvnsQ?html5=1" frameborder="0" allowfullscreen ></iframe>
</div

<div class="you-tube-videos">
<iframe class="youtube-player" type="text/html" width="640" height="385" src="http://www.youtube.com/embed/LWa2SQ2epus?html5=1" frameborder="0" allowfullscreen ></iframe>
</div




<!-- btn btn-social btn-github pull-right -->

<a class="btn btn-github" role="button" style="margin-top:16px;" href="https://github.com/ASNApalooza/Walter.Query.Tester/archive/master.zip" download="walter-query-tester.zip">
<span class="fa fa-download"></span> Download Query Tester from GitHub
</a>

<a class="btn btn-github" role="button" style="margin-top:16px;" href="https://github.com/ASNApalooza/Walter.Query.Tester">
<span class="fa fa-github"></span> See the Query Tester project on GitHub
</a>
<!-- End: qf-query-tester.html -->
<!-- Begin: qf-walter-web.html -->
            <div id="qf-walter-web" class="content section">
              <h2>Walter Web example</h2>
                <p></p>
<!-- End: qf-walter-web.html -->
<!-- Begin: qf-walter-windows.html -->
            <div id="qf-walter-windows" class="content section">
              <h2>Walter Windows example</h2>
                <p></p>
<!-- End: qf-walter-windows.html -->
<!-- Begin: qf-export-to-datatable.html -->
            <div id="qf-export-to-datatable" class="content section">
              <h2>Export to DataTable</h2>
              <p>This example shows how to use Walter to export query results to a DataTable. This code could be used in either Windows or ASP.NET to bind data to a grid or other control. Exporting to a DataTable uses Walter's default output adapter so you'll notice that no explicit output adapter instancing is required. You'll see that later with the other output adapters.</p>
              <p>Don't let the concept of output adapters seem too mysterious. An output adapter is just a class that implements a simple interface. Output adapters get passed a DataTable by Walter's query engine and it's the output adapter's job to translate that incoming DataTable into something else. Walter's default output adapter emits a datatable&mdash;and as you can probably guess, it didn't take much code to produce this output adapter. It simply delivers the internal DataTable. More on output adapter internals later. Let's dig into how to use the default DataTable output adapter.</p> 

                <pre class="prettyprint linenums">Using ASNA.Helpers.DataServices
  
DclFld db     Type(AdgConnection)
DclFld Query  Type(QueryDriver) 

db = *New AdgConnection("*Public/IBMi") 

Query = *New QueryDriver(db)
Query.Args.Inputs.Library    = "examples"
Query.Args.Inputs.File       = "CMastNewL2"
Query.Args.Inputs.FieldsList = "CMCUSTNO,CMNAME,CMSTATE"
Query.Args.Inputs.Rows       = 1000
Query.Args.Inputs.Query      = "CMSTATE = '{CMSTATE}'"
Query.Args.Inputs.QueryParms.Add(*New QueryField("CMSTATE",State))

grid.DataSource = Query.Exec() *As DataTable

db.Close()</pre>


<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-export-to-datatable-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-export-to-datatable-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Most of Walter lives in the ASNA.Helpers.DataServices namespace. This using statement makes Walter's QueryDriver, QueryField, and QueryType objects available without needing to qualify them with their namespace.</td>
                </tr>
                <tr>
                <td>03</td>
                <td>Declare a DataGate DB connection. This is the core DB connection used by AVR's DclDB. Both DB connections participate in DataGate connection pooling and they both use the same Database Name scheme. This DB connection must be instanced before Walter's QueryDriver is instanced.</td>
                </tr>
                <tr>
                <td>04</td>
                <td>The QueryDriver is Walter's traffic cop&mdash;all of Walter's goodness flows through it.When you look at its source code, you'll see there really isn't much to the QueryDriver, it's mostly a convenience class to make it easy to stitch together the class instances that Walter needs. Most of what Walter needs is surfaced through the Query Driver. Its constructor needs to be passed an instanced (but not necessarily connected) DataGate DB connection</td>
                </tr>
                <tr>
                <td>06</td>
                <td>Instance the database connection with an ASNA DataGate database name.</td>
                </tr>
                <tr>
                <td>08</td>
                <td>The QueryDriver surfaces a layered set of classes that provides access to Walter's inputs, outputs, and error information. (In retrospect I regret aspects of this layered design and wish I had done something else. That's what I get for coding first and designing second!.) The QueryDriver receives all of its inputs through its Args.Inputs class. You'll later see that by flowing all inputs through the Args class provides another interesting way of instancing Walter (hint: if you serialize the Args.Inputs class to Json, you can easily "hydrate" an instance of Walter by via Json serialization. More on this later.) This line instance the QueryFile object which under the covers instances its Arg.Inputs class&mdash;ready to accept query inputs.</td>
                </tr>
                <tr>
                <td>09</td>
                <td>Specify the library for the query. This can be either a library name or the special value, *LIBL.</td>
                </tr>
                <tr>
                <td>10</td>
                <td>Specify the file name name for the query. Just a reminder, remember these values are specified at runtime. Unlike the tradition use of AVR's DclDiskFile, Walter has no knowledge of the file you want to use at compile time. (Note: a glaring omision in Walter surfaces itself here: Walter lacks the ability to specify a member name. Walter currently works only with the first member. This is one of the first things to add to Walter after ASNApalooza!).</td>
                </tr>
                <tr>
                <td>11</td>
                <td><a name="location-fieldslist"></a>Specify a comma separated list of fields to include in the query results. This is a case-insensitive comma-separated list of field names. Each field name specified must exist in the record format. For basic uses, this list is used as it is shown here. But an alternative syntax is comma-separated list of fieldnames and column aliases. For example, in this list: "CMCUSTNO:Number, CMNAME:Name, CMADDR1:Address" the field name is provided first then a column and the field alias. The use of the field alias is adapter-specific. For example, Walter's Excel output adapter uses field aliases for column names and its Json output adapter uses field aliases to name the field in the resulting Json. Field aliases aren't used by the default DataTable output adapter. The simple delimited field list is that adapter needs. The resulting datatable will include only the field columns specified in this list. Note that even if you don't need the field in the resulting output, if a field is used in the query definition (line 13 below), it <em>must</em> be included in this list.</td>
                </tr>
                <tr>
                <td>12</td>
                <td>Specify the maximum number of rows for the query to return. A value of -1 means to return all rows that match query specs. Be careful using this option&mdash;it's probably not prudent to try to bind 100,000 rows to the ASP.NET grid or </td>
                </tr>
               <tr>
                <td>13</td>
                <td>Specify the query. This can use AND and OR statements and it specifies tokens that are replaced at runtime within braces. This parameterized query is resolved with values from the QueryParms. <em>Every</em> field in this query <em>must</em> be included in the following QueryParms collection. Note: Watch the placement of the single apostrophes carefully. This query follows open query file rules and for character values the apostrophes are necessary. As a tease, consider this: because Walter's queries are executed on the IBM i through Open Query File, advanced query facilities such as translation tables (for case insensitive searches), 'contains' searches (eg, any address with the word "Avenue" in it), range queries, and wild card queries are possible when Walter is used against the IBM i. Walter surfaces some pretty amazing, and surprising fast, query capabilities.</td>
                </tr>
                <tr>
                <td>14</td>
                <td>The QueryParms collection provides the field values for the replaceable tokens specified in the Query property. In this example, the replacement token {CMSTATE} is replaced by the value in the State variable at runtime. For example, if the State variable value is 'IN' then the query in line 14 resolves to CMSTATE = 'IN' at runtime. Each field used in the query must be represented by a corresponding field in the QueryParms collection. </td>
                </tr>
                <tr>
                <td>16</td>
                <td>Call the QueryDriver's Exec() method to execute its query. The default output adapter returns a DataTable and (because other adapters can return other types) the return value from the adapter in use <em>must</em> be cast appropriately. With Walter having produced the DataTable, you can now do anything with it you want. In many cases, it will be bound to either a Windows or ASP.NET grid control.</td>
                </tr>
                <tr>
                <td>18</td>
                <td>Close the underlying database server connection. This should always be done after you use Walter's QueryDriver's Exec() method. This connection does participate in connection pooling so there is very little overhead in reconnecting.  </td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->

Queries are independent of their output format so the same core query used to explain the DataTable output adapter will be used to explain the output adapters. The discussion on other output adapters will focus on how the adapters redirect output. Later in this document we'll drill deeper into more details about Walter's query capabilities. 
                <hr>
            </div>
<!-- End: qf-export-to-datatable.html -->
<!-- Begin: qf-excel-to-file.html -->
            <div id="qf-excel-to-file" class="content section">
              <h2>Export to Excel</h2>
              <p>This example shows how to use Walter to create an Excel spreadsheet in a Windows program and save it to a local file. A later section shows how you can use Walter to produce an Excel spreadsheet in an ASP.NET app. </p>
              <p>Walter's Excel output adapter uses the open source <a href="https://closedxml.codeplex.com/">ClosedXML library</a>, which provides a rational API over Microsoft's <a href="http://msdn.microsoft.com/en-us/library/office/bb448854(v=office.15).aspx">Open XML SDK for Office.</a>. I chose the ClosedXML library because it is an active project, has the features Walter needed, and has pretty good documentation. There are many alternatives for writing Excel spreadsheets in the .NET environment. If Walter's Excel output adapter doesn't suit you, write your own!</p>
              <p>Walter's default Excel output adapter accepts two query options (through Walter's Inputs.Options collection) to specify the spreadsheet heading and the worksheet name. Through clever use of the Inputs.Options collection a scheme could probably be produced to specify to the Excel output adapter to create column and row total formulas. This has been on my todo list for months. Alas, that's why Walter is open source! Help please!</p> 

<pre class="prettyprint linenums">Using ASNA.Helpers.DataServices
DclFld db           Type(AdgConnection)
DclFld Query        Type(QueryDriver) 
DclFld ExcelAdapter Type(ToExcelAdapter)

db = *New AdgConnection("*Public/IBMi")

Query = *New QueryDriver(db)
Query.Args.Inputs.Library    = "examples"
Query.Args.Inputs.File       = "CMastNewL2"
Query.Args.Inputs.FieldsList = "CMCUSTNO:Number,CMNAME:Name,+
                                CMADDR1:Address,CMCITY:City,CMSTATE:State"
Query.Args.Inputs.Rows       = 1000
Query.Args.Inputs.Query      = "CMSTATE = '{CMSTATE}'"
Query.Args.Inputs.QueryParms.Add(*New QueryField("CMSTATE",State))

Query.Args.Inputs.Options.Add("heading","Customer Listing")
Query.Args.Inputs.Options.Add("worksheet_name","Customers")

ExcelAdapter = *New ToExcelAdapter(Query.Args) 
Query.OverrideAdapter(*New ToExcelAdapter(Query.Args))
Query.Exec() 
db.Close()
ExcelAdapter.SaveToLocalFile("c:\users\public\documents\test.xlsx")</pre>


<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-excel-to-file-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-excel-to-file-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Make the QueryDriver, QueryField, and QueryType objects available without needing to qualify them with their namespace.</td>
                </tr>
                <tr>
                <td>03</td>
                <td>Declare a DataGate DB connection. </td>
                </tr>
                <tr>
                <td>04</td>
                <td>Declare an instance of the QueryDriver. </td>
                </tr>
                <tr>
                <td>05</td>
                <td>Declare an instance of the standard Excel output adapter. Note that it isn't instanced when you declare it--we'll instance it in a moment.</td>
                </tr> 
                <tr>
                <td>07</td>
                <td>Instance the database connection.</td>
                </tr>
                <tr>
                <td>09</td>
                <td>Instance the QueryFile object.</td>
                </tr>
                <tr>
                <td>10</td>
                <td>Specify the library for the query.</td>
                </tr>
                <tr>
                <td>11</td>
                <td>Specify the file for the query.</td>
                </tr>
                <tr>
                <td>12</td>
                <td>Specify a comma separated list of fields to include in the query results. In addition to the field name, you can also provide (preceded by a comma) a field name alias. The use of this alias is specific to an output adapter. The Excel output adapter uses these field aliases for column headings in the spreadsheet. For example, The CMCUSTNO field will have a column heading of "Number."</td>
                </tr>
                <tr>
                <td>13</td>
                <td>Specify the maximum number of rows for the query to return. Be especially careful with this value when using the Excel output adapter. The entire spreadsheet is created in memory before it is produced.</td>
                </tr>
                <tr>
                <td>14</td>
                <td>Specify the query.</td>
                </tr>
                <tr>
                <td>15</td>
                <td>The QueryParms collection provides the field values for the Query property. In this example, the replacement token {CMSTATE} is replaced by the value in the State variable (not declared in this code snippet) at runtime. For example, if the State variable value is 'IN' then the query in line 14 resolves to CMSTATE = 'IN' at runtime. Each field used in the query must be represented by a corresponding field in the QueryFields collection. </td>
                </tr>
                <tr>
                <td>17</td>
                <td>Specify query options. The use of query options is specific to the output adapter being used. The Excel output adapter uses two options. This option defines the heading used in the spreadsheet. </td>
                </tr>
                <tr>
                <td>18</td>
                <td>This query option specifies the spreadhseet worksheet name. If either the 'heading' or 'worksheet_name' options are omitted when using the Excel output adapter, default values are used.</td>
                </tr>
                <tr>
                <td>20</td>
                <td>Instance the standard Excel output adapter. Most output adapters require the Query.Args instance as the only constructor argument. This makes the input args available to adapter. How the adapter may use those values is specific to a given output adapter.</td>
                </tr>
                <tr>
                <td>21</td>
                <td>Override the output adapter with the newly instanced Excel adapter. When the output adapter is overridden no other query results are generated--query results are always passed out of Walter through a single query adapter. For example, having overridden the output adapter with the Excel output adapter the query will not generate a data table.</td>
                </tr>
                <tr>
                <td>22</td>
                <td>Call the QueryDriver's Exec() method to execute its query. In the case of the standard Excel output adapter, nothing is returned from this method.</td>
                </tr>
                <tr>
                <td>23</td>
                <td>Close the underlying database server connection. This should always be done after you use Walter's QueryFile.Exec() method. This connection does participate in connection pooling so there is very little overhead in reconnecting.  </td>
                </tr>
                <tr>
                <td>24</td>
                <td>Use the standard Excel output adapter's SaveToLocalFile() method to save the spreadsheet created. This option is only valid for use with Windows applications. Walter also has an ASP.NET helper class that can use the Excel output adapter in an ASP.NET app.</td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->


<p>The spreadsheet produced by the code above is shown below:
<img src="public/images/spreadsheet.png" class="img-responsive">


                <hr>
            </div>
<!-- End: qf-excel-to-file.html -->
<!-- Begin: qf-export-to-json.html -->
            <div id="qf-export-to-json" class="content section">
              <h2>Export to Json</h2>
                <p>Walter is a component that performs dynamic read-only queries against DataGate databases. It works against physical and logical files. Walter aims to provide a declarative model that makes is easy to fetch performant dynamic query results with a minimal of effort and with a high . It takes about 12 lines of code to configure Walter and produce output with it. When used against the IBM i, Walter consistently produces output in less than 1/10 of a second. </p>

                <pre class="prettyprint linenums">Using ASNA.Helpers.DataServices

DclFld db     Type(AdgConnection)
DclFld Query  Type(QueryDriver) 
DclFld Json   Type(*String)

db = *New AdgConnection("*Public/IBMi") 

Query = *New QueryDriver(db)
Query.Args.Inputs.Library    = "examples"
Query.Args.Inputs.File       = "CMastNewL2"
Query.Args.Inputs.FieldsList = "CMCUSTNO:number,CMNAME:name,CMSTATE:state"
Query.Args.Inputs.Rows       = -1
Query.Args.Inputs.Query      = "CMSTATE = '{CMSTATE}'"
Query.Args.Inputs.QueryFields.Add(*New QueryField("CMSTATE",State))

Query.OverrideAdapter(*New ASNA.Helpers.DataServices.ToJsonAdapter(Query.Args)) 

Json = Query.Exec() *As *String</pre>


<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-export-to-json-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-export-to-json-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01-15</td>
                <td>Line 5 declares a string variable named "Json" to receive Walter's resulting Json. Otherwise lines 1-15 are the same as 
                as the other output types.</td>
                </tr>
                <tr>
                <td>17</td>
                <td>Override Walter's default output adapter with its standard Json adapter. This Json output adapter uses the field aliases
                 specified on line 12 to name the data keys in the Json (more on this in a moment).</td>
                </tr>
                <tr>
                <tr>
                <td>19</td>
                <td>Produce the Json.</td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->

A sample of Walter's Json is shown below. Note that each field is identified by the keys specified with the field alises in Line 12 of the code above. The "list" node in the Json is the Json list. The other nodes are informational meta data about the query that might come in handy. This query meta will be discussed in more detail later. 
<br/><br/>
<pre class="prettyprint linenums">{
  "resultRowCount": 4,
  "totalRowCount": 995,
  "rowCountPhrase": "4 of ~995",
  "milliseconds": "41",
  "list": [
    {
      "number": "11200",
      "name": "Marley Services Cooperative Blue Tech",
      "state": "IN"
    },
    {
      "number": "5400",
      "name": "Red Laboratories Inc Computer Inc",
      "state": "IN"
    },
    {
      "number": "10300",
      "name": "Howard Corporation Consulting Assoc Inc",
      "state": "IN"
    },
    {
      "number": "40400",
      "name": "Port Inc Systems Agents Associates",
      "state": "IN"
    }
  ],
  "startingKey": [],
  "endingKey": []
}</pre>
<!-- End: qf-export-to-json.html -->
<!-- Begin: qf-export-to-listitem.html -->
            <div id="qf-export-to-listitem" class="content section">
              <h2>Export to ListItem array</h2>
              <p>This example shows how to use Walter to export query results to an array of ListItems. An array of ListItems would most usually be used to populate ASP.NET DropDownList or the Windows ComboBox.

                <pre class="prettyprint linenums">01 Using ASNA.Helpers.DataServices
Using System.Web.UI.WebControls 
...
DclFld db           Type(AdgConnection)
DclFld Query        Type(QueryDriver) 
DclArray ListItems  Type(ListItem) Rank(1)

db = *New AdgConnection("*Public/IBMi")

Query = *New ASNA.Helpers.DataServices.QueryDriver(db)
Query.Args.Inputs.Library    = "examples
Query.Args.Inputs.File       = "States"
Query.Args.Inputs.FieldsList = "State:text,Abbrev:value"
Query.Args.Inputs.Rows       = -1
Query.Args.Inputs.Query      = "STATE >= 'A'"
Query.Args.Inputs.QueryFields.Add(*New ASNA.Helpers.DataServices.QueryField("STATE",""))

Query.OverrideAdapter(*New ASNA.Helpers.DataServices.ToLisItemArrayAdapter(Query.Args)) 

ListItems = Query.Exec() *As ListItem[]

db.Close()</pre>

<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-export-to-listitem-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-export-to-listitem-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Add the Make the QueryDriver, QueryField, and QueryType objects available without needing to qualify them with their namespace.</td>
                </tr>
                <tr>
                <td>02</td>
                <td>Make the ListItem object available to the app.</td>
                </tr>
                <tr>
                <td>04</td>
                <td>Declare a DataGate DB connection.</td>
                </tr>
                <tr>
                <td>05</td>
                <td>Declare an instance of the QueryDriver. This is Walter's core query object.</td>
                </tr>
                <tr>
                <tr>
                <td>06</td>
                <td>Declare an array of ListItems. This will contain the result of Walter's query.</td>
                </tr>
                <tr>
                <td>08</td>
                <td>Instance the database connection.</td>
                </tr>
                <tr>
                <tr>
                <td>10</td>
                <td>Instance the QueryFile object.</td>
                </tr>
                <tr>
                <td>11</td>
                <td>Specify the library for the query.</td>
                </tr>
                <tr>
                <td>12</td>
                <td>Specify the file name name for the query.</td>
                </tr>
                <tr>
                <td>13</td>
                <td>Specify the fields from the file to return. The ToListItemArray output adapter requires field aliases to indicate which fields provide the text and values properties for the 
                    list item. The syntax of each field then is <FieldName>:<AliasName>.</td>
                </tr>
                <tr>
                <td>14</td>
                <td>Specify the maximum number of rows for the query to return. -1 means return all of the rows that satisfy the query.</td>
                </tr>
                <tr>
                <td>15</td>
                <td>Specify the query. This can use AND and OR statements and it specifies tokens that are replaced at runtime. See the next line for more info.</td>
                </tr>
                <tr>
                <td>16</td>
                <td>The QueryFields collection provides the field values for the Query property. In this example, the query is a static query&dash;that is there aren't any dynamic parameters needed for the query. However, you still need to provide a QueryField for the fields used in a static query; the value for fields used in a static query aren't used.</td>
                </tr>
                <td>18</td>
                <td>Override Walter's default output adapter with the ToListItemArray adapter. A reference isn't needed anywhere for this adapter so it is instanced inline.</td>
                </tr>
                <tr>
                <td>20</td>
                <td>Use the QueryDriver's Exec() method to execute its query, being sure to cast its result to the type returned by the output adapter.</td>
                </tr>
                <tr>
                <td>22</td>
                <td>Close the underlying database server connection. This should always be done after you use Walter's QueryFile.Exec() method. This connection does participate in connection pooling so there is very little overhead in reconnecting.</td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->

<p>The code below shows how to use the array of ListItems to populate a Windows ComboBox. The ListItem object resides in the System.Web.UI.WebControls class. Therefore, when you use Walter to return an array of ListItems for a Windows app, be sure to add a reference to the System.Web assembly and adding a using state for System.Web.UI.WebControls.

                <pre class="prettyprint linenums">Using System.Web.UI.WebControls
...
comboboxStates.Items.Clear()
comboboxStates.Items.AddRange(ListItems) 
comboboxStates.SelectedIndex = 0</pre> 

<p>The code above shows how to use the Windows ComboBox's AddRange() method to assign the resulting ListItemArray to the ComboBox. Similiar code is used with the ASP.NET DropDownList control.</p>
<pre class="prettyprint linenums">
BegSr comboboxStates_SelectedIndexChanged Access(*Private) +
                      ent(*this.comboboxStates.SelectedIndexChanged)
    DclSrParm sender Type(*Object)
    DclSrParm e Type(System.EventArgs)

    DclFld li Type(ListItem) 

    li = comboboxStates.SelectedItem *As ListItem
    // li.value = item's value.
    // li.text =item's text.
EndSr</pre>

<p>Use the code above to fetch the selected ListItem from a Windows ComboBox. The selected ListItem provides the select text and value for the selected item.</p>



                <hr>
</div><!-- content section-->

<!-- End: qf-export-to-listitem.html -->
<!-- Begin: qf-jquery-autocomplete.html -->
            <div id="qf-jquery-autocomplete" class="content section">
              <h2>jQuery AutoComplete</h2>
                <p>Prior to the advent of Ajax, doing look-ups for data entry fields in Web pages was a kludgy, nasty thing. We had to launch a new browser window with JavaScript's klunky Window.Open(), which offered very little in the way of programmatic control (eg, it was quite challenging to position the 'lookup' window correctly. </p>
                <p>But along came Ajax and with a little CSS help, we can now do some pretty cool lookups. The downside is that the code required can be quite fiddly and you need to program both the client-side and the server-side. Worry not, Walter's data goodness extends to the Web quite nicely. Another part of Walter, ASNA.Helpers.ASPNET provides a JavaScript interface over Walter's query capabilities as well as the HTTP handler and JavaScript you need to very easily hook up an AutoComplete in your ASP.NET Web apps. </p>
                <p>The image below shows the jQuery AutoComplete in action with Walter. The jQuery AutoComplete expects a Json structure with 'label' and 'value' nodes for each entry that matches the search. </p>

<img src="jquery-autocomplete-in-action.png"/>

                <p>The label is the text to display and the value is the associated value to return. For example, when looking up states, the full state name would be the label and the state abbreviation would be the value; or when looking up a customer number the customer name could be the label and the customer number could be the value.</p>

                <p>jQuery AutoComplete does all the UI work client side and works with either either HTML elements or ASP.NET controls to define the inputs. The code below shows using ASP.NET controls. In this case, we'll display both values, but in the real world, you'd typically stash the value looked up in a hidden input element.</p>

<pre class="prettyprint linenums">&lt;asp:TextBox ID=&quot;textboxCustomerName&quot;   runat=&quot;server&quot; 
             EnableViewState=&quot;False&quot; ClientIDMode=&quot;Static&quot;&gt;&lt;/asp:TextBox&gt;
&lt;asp:TextBox ID=&quot;textboxCustomerNumber&quot; runat=&quot;server&quot; 
             EnableViewState=&quot;False&quot; ClientIDMode=&quot;Static&quot;&gt;&lt;/asp:TextBox&gt;</asp:TextBox></pre>

              <p>Given the elements above, the entire JavaScript you need to provide to AutoComplete an input field is shown shown below. Lines 1-11 show Walter's JavaScript query interface and the line 13 is jQuery AutoComplete-specific.</p>

<pre class="prettyprint linenums">var ACCustomerName = new ASNAHelpers.QueryInputArgs();
ACCustomerName.url = "../services/jsonservice.ashx";
ACCustomerName.Library = "examples";
ACCustomerName.File = "cmastnewl2";
ACCustomerName.FieldsList = "cmname:label,cmcustno:value";
ACCustomerName.Rows = 12;
ACCustomerName.Query = "CMNAME >= '{CMNAME}'";
ACCustomerName.addQueryParm("CMNAME");
ACCustomerName.addOption("labelTargetId", "textboxCustomerName");
ACCustomerName.addOption("labelValueId", "textboxCustomerNumber");
ACCustomerName.addOption("showLabelOnScroll", true);

ASNAHelpers.autoComplete.registerQuery(ACCustomerName);</pre></code>

<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-jquery-autocomplete-annotation">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-jquery-autocomplete-annotation" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Create an instance of ASNAHelpers.QueryInputArgs. This is the JavaScript object that ASNA.Helpers.ASPNET provides to implement the JavaScript interface to Walter's query engine. You need one instance of this object for each input field that needs AutoComplete. Except for minor syntaxes with the way values are added to the QueryParms, OrderBy fields, and query Option collections, the JavaScript required to create a Walter query with JavaScript is nearly the same as it is to create on server side with AVR or C#.</td>
                </tr>
                <tr>
                <td>02</td>
                <td>Set the URL of Walter's HTTP Handler ASHX file. By default it's located in the 'services' folder in the Web app's root folder.</td>
                </tr>

                <tr>
                <td>03</td>
                <td>Set the library for the Walter query.</td>
                </tr>

                <tr>
                <td>04</td>
                <td>Set the file name for the Walter query.</td>
                </tr>

                <tr>
                <td>05</td>
                <td>Set the FieldsList for the Walter query.</td>
                </tr>

                <tr>
                <td>06</td>
                <td>Set the number of rows for the Walter to return.</td>
                </tr>

                <tr>
                <td>07</td>
                <td>Specify the Walter query selection.</td>
                </tr>

                <tr>
                <td>08</td>
                <td>Set the query parms for the Walter Query. Walter's AutoComplete expects the first field to be the field for which the value the uses enters to be the lookup value. However, additional query parameters could be provided to further scope the query. </td>
                </tr>


                <tr>
                <td>09</td>
                <td>Walter's AutoComplete implementation expects at least one one query helper to be provided. The first, which provides the 'labelTargetId' is the element ID of the input element to which you want to attach a jQuery AutoComplete. </td>
                </tr>

                <tr>
                <td>10</td>
                <td>'labelValueId' provides the element Id into which the selected value should be placed..</td>
                </tr>

                <tr>
                <td>11</td>
                <td>By default, the jQuery AutoComplete wants to display the values as the user scrolls through them. In some cases, though, it might be preferable to show the label as the values are scrolled. Take a look at the AutoComplete it is showing labels, so it has showLabelOnScroll set to 'true'.</td>
                </tr>

                <tr>
                <td>13</td>
                <td>Once you've defined the Walter query with JavaScript, line 13 registered that query with the jQuery UI AutoComplete. 
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->

<p>Walter leans on jQuery's AutoComplete to do much of the heavy lifting, but Walter does kick in his own JavaScript for the task. Let's see how easy it is. First, use the Component Installer to ensure you get all the binaries, Javascript and other files you need. 


<!-- End: qf-jquery-autocomplete.html -->
<!-- Begin: qf-jquery-datatable.html -->
            <div id="qf-jquery-datatable" class="content section">
              <h2>jQuery DataTable</h2>
                <p>Coming soon!</p>
<!-- End: qf-jquery-datatable.html -->
<!-- Begin: qf-query-syntax.html -->
            <div id="qf-query-syntax" class="content section">
              <h2>Query Syntax</h2>
                <p>Coming soon!</p>
<!-- End: qf-query-syntax.html -->

          </div><!-- /.col-sm-9 -->
        </div>

      </div> <!-- .components -->

<!--       <div class="tab-pane" id="about">
        <h1>About</h1>
        <p class="lead">This section is for about and resources.</p>
      </div>      
 -->
    </div><!-- /.container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

    <!-- jQuery Version 1.11.0 -->
    <script src="public/vendor/jquery/dist/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="public/vendor/bootstrap/dist/js/bootstrap.min.js"></script>
    <script src="public/GooglePrettify/prettify.js"></script>
    <script src="public/magnific-popup/jquery.magnific-popup.min.js"></script>
    <script src="public/js/fitvids.js"></script>



<!--
    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
-->
    <script>

      /* scroll to top when clicked on navbar */
      $(".navbar > .container").on("click", function(e){
        $('html,body').animate({scrollTop:0},'slow');
      });

      /* brand logo click */
      $(".navbar-brand").on("click",function(){
        $("#home").addClass("active").siblings().removeClass("active");
        $("#tabs > li").removeClass("active");
      });

      /* make list-group selectable */
      $(".list-group>a").on("click", function(){
        $(this).addClass("active").siblings().removeClass("active");
      });

      /* auto select list-group item on scroll */
      $(document).scroll(function(){
        $('.section').each(function(){
          var position = $(document).scrollTop() - $(this).offset().top;
          if(position < 30 && position > -115) {
            $($('a[href$='+$(this).attr("id")+']')).click();
          }
        });      
      });

      /* set hash on tab select */
      $('#tabs a').click(function() {
        window.location.hash = $(this).attr("href");
        $(document).scrollTop(0);
        $(".list-group > a").removeClass("active");
      });

      $(document).ready(function(){

        if(window.location.hash !== ""){
          /* open tab based on hash value */
          if($('#tabs > li > a[href="'+window.location.hash+'"]').length){
            $('#tabs > li > a[href="'+window.location.hash+'"]').tab('show');
            setTimeout(function(){$(document).scrollTop(0)}, 200);
          }
          /* open tab and section based on hash value */
          if($('.list-group > a[href="'+window.location.hash+'"]').length){
            var tab = $('.list-group > a[href="'+window.location.hash+'"]').closest(".tab-pane").attr("id");
            $('a[href="#'+tab+'"]').tab('show');
            $('.list-group > a[href="'+window.location.hash+'"]').click();
            setTimeout(function(){$(document).scrollTop($(window.location.hash).offset().top)}, 200);
          }

          $('.query-test-screen-shots-popup-gallery').magnificPopup({
            delegate: 'a',
            type: 'image',
            tLoading: 'Loading image #%curr%...',
            mainClass: 'mfp-img-mobile',
            gallery: {
              enabled: true,
              navigateByImgClick: true,
              preload: [0,1] // Will preload 0 - before current, and 1 after the current image
            },
            image: {
              tError: '<a href="%url%">The image #%curr%</a> could not be loaded.',
              titleSrc: function(item) {
                var detailText = item.el.attr('data-detail');
                if (typeof detailText === 'undefined') {
                  detailText = "";
                }
                return item.el.attr('title') + '<small>'+ detailText + '</small>';
              }
            }
          });


        }


        prettyPrint();

        $(".you-tube-videos").fitvids();

      });
    </script>
  </body>
</html>
