<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="favicon.ico">

    <title>Walter</title>

    <!-- Bootstrap core CSS -->
    <!-- <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css"> -->
    <link href="public/vendor/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="public/css/index.css" rel="stylesheet">


    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>

.content {padding-top: 80px ;padding-bottom: 20px}

@media (min-width:768px){
  #components .list-group {position: fixed; width:18%;}
}

@media (min-width:1024px){
  #components .list-group {position: fixed; width:18%;}
}

@media (min-width:1400px){
  #components .list-group {position: fixed; width:14%;}
}

@media (min-width:1920px){
  #components .list-group {position: fixed; width:14%;}
}
    </style>

  </head>

  <body>

    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Home</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav" id="tabs">
            <li><a href="#components" data-toggle="tab">Documentation</a></li>
            <li><a href="#about" data-toggle="tab">About</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="content container tab-content">

      <div class="tab-pane active" id="home">
        <div class="jumbotron">
          <h1>Some Framework</h1>
          <p>This is a template for a documentation website for a programming framework or library. It includes a template for components description with a navigation list.</p>
          <p><a href="#" class="btn btn-primary btn-lg" role="button">Download &darr;</a></p>
        </div>
      </div>

      <div class="tab-pane" id="components">
        <div class="row">
          <div class="col-sm-3">
            <div class="list-group">
              <a href="#qf-overview" class="list-group-item">Overview</a>
              <a href="#qf-export-to-datatable" class="list-group-item">Export to DataTable</a>
              <a href="#qf-excel-to-file" class="list-group-item">Export to Excel file</a>
              <a href="#qf-export-to-listitem" class="list-group-item">Export to ListItem array</a>
              <a href="#item3" class="list-group-item">Item #3</a>
              <a href="#item4" class="list-group-item">Item #4</a>
              <a href="#item5" class="list-group-item">Item #5</a>
              <a href="#item6" class="list-group-item">Item #6</a>
              <a href="#item7" class="list-group-item">Item #7</a>
              <a href="#item8" class="list-group-item">Item #8</a>
              <a href="#item9" class="list-group-item">Item #9</a>
              <a href="#item10" class="list-group-item">Item #10</a>
              <a href="#item11" class="list-group-item">Item #11</a>
              <a href="#item12" class="list-group-item">Item #12</a>
            </div>
          </div><!-- /.col-sm-3 -->

          <div class="col-sm-9">
            <div class="clearfix">
               <h1>What is Walter?</h1>
              <!-- <div class="col-sm-3"> -->
                <div class="pull-left thumbnail  space-right">
                  <img src="public/images/walter.png"/>
                  <div class="text-center">
                    <a class="black" href="http://www.joshuabudich.com/"><small>Image by Joshua Budich</small></a>
                  </div>
                </div>
              <!-- </div> -->
              <!-- <div class="col-sm-9"> -->
                <p class="lead">In the Big Lebowski, Walter Sobchak was The Dude's faithful sidekick. This library
                is intended to be a faithful sidekick for your AVR projects. Walter's specialty is in executing 
                dynamic, declarative queries that produce read-only lists in a variety of formats for your AVR for .NET 
                applications.</p>
                <p class="lead">Let's see what Walter can do for you.
            </div>

<!-- Begin: qf_overview.html -->
            <div id="qf-overview" class="content section">
              <h2>Walter overview</h2>
                <p>Walter is a component that performs dynamic read-only queries against DataGate databases. It works against physical and logical files. While Walter is intended primarily for ASNA Visual RPG, it would also work just fine with VB.NET or C#. 

                <p>Walter implements a declarative programming model that makes is easy to fetch dynamic query results with a minimal of effort and with high performance. When used against the IBM i, Walter consistently produces output with
                subsecond response times (usually less than 250 milliseconds). It takes about 1-15 lines of code to configure Walter and produce output with it. Part of the reason I wrote Walter is that I got tired of needing to create an endless supply of custom classes for reading data and producing that data in a variety of formats.</p>

                <p>Some of Walter's design goals are:
                <ul>
                <li>Allow runtime configuration of queries, including library, file, fields, selection criteria, and sort
                order with a declarative, logic-free syntax. You only need to tell Walter what you want, you don't need
                tell how it how to get it.</li>
                <li>Provide dynamic, performant query capabilities independent of the availability of explicit access paths 
                provided by logical files. Walter works with the local ASNA DataBase, but really shines when used with the 
                IBM i. On the IBM i, Walter puts OpenQueryFile to good use. Walter also works with ASNA's DataGate for 
                SQL Server, but has been tested the least there so far.</li>
                <li>Provide built-in, key-driven paging support. When used against logical files with a known key 
                structure, Walter provides built in forward paging. You don't have to manage "next" key values and Walter
                tells you when the last page has been read.</li>  
                <li>Support several standard output types but also provide an plug-in model so that additional output
                types can easily be added later. Walter's default output type is a System.Data.DataTable, but it includes
                output adapters to produce an array of ListItems (for populating drop-down lists in Windows and Web
                applications), Excel spreadsheets (in native XLSX format), and Json for client-side JavaScript use. </li>
                <li>Allow a common way to pass query meta data into Walter's output adapters. This allows each output
                adapter a measure of customization. For example, Walter's Excel output adapter uses this meta data 
                to provide a spreadsheet heading and the worksheet name.</li>
                <li>Provide robust error handling so trouble-shooting is easy.</li>
                <li>Allow for the easy aliasing of field names so that, for example, when producing an Excel spreadsheet
                user-friendly column names are available.</li> 
                <li>Be usable by any .NET application type. Walter works with Windows, ASP.NET and Web services and can be coded
                in AVR, VB.NET, C# or even JavaScript. Walter makes a great partner for extending ASNA Wings, Monarch and 
                even Mobile RPG applications. Walter can be used directly to create department-level projects or it can be used as a primitive in the creation of more robust database repository class libraries (where it could be tapped to produce lists for those libaries). Walter has a sister project, ASNA.Helpers.ASPNET that provides helper facilities
                for using Walter in ASP.NET applications.</li>
                <li>Provide an interactive query tester for creating and testing queries and generating the AVR, C#, or even
                JavaScript. </li>
                <li>Be formally open sourced so that others can easily extend, enhance, and bugfix Walter.</li>
                </p>

                <p>Walter's query output is driven by output adapters. The default output adapter emits query output as a DataTable. The DataTable can be bound to most Windows and ASP.NET controls (including Windows' DataGridView and ASP.NET's GridView). Walter also includes output adapters to emit query results as: </p>

                <ul class="task-list">
                <li><strong>Json</strong>. Walter's Json output can be used in a variety of ways including feeding a JavaScript autocomplete widget (such as jQuery UI's <a href="http://jqueryui.com/autocomplete/">AutoComplete</a>) or feeding a client grid such as the jQuery DataTable grid. Walter includes an HTTP handler to make its Json output easy to use with ASP.NET. A small JavaScript wrapper for the jQuery UI AutoComplete widget is included. Using Walter and its components make it very easy to add AutoComplete to your ASP.NET pages (including Wings and Monarch pages). </li>
                <li><strong>Excel</strong>. Walter's Excel adapter produces Excel spreadsheets (in XSLX format) on either Windows Web servers or Windows clients, without needing Excel installed. This adapter uses the <a href="https://closedxml.codeplex.com/">ClosedXML</a> library (which itself is a wrapper around Microsoft's <a href="http://msdn.microsoft.com/en-us/library/office/bb448854(v=office.15).aspx">Open XML SDK)</a>.<br>
                </li>
                <li><strong>ListItem array</strong>. This adapter produces a ListItem array for populating ASP.NET's DropDownList controls or Windows's ComboBox. </li>
                </ul>
                <p></p><p>Should you need some other output type, it's easy to write your own output adapters by implementing a simple interface that Walter provides.</p>
                <p>The next several sections provide overviews of using Walter with several of its outputs. 

                <hr>
            </div>
<!-- End: qf_overview.html -->

<!-- Begin: qf-export-to-datatable.html -->
            <div id="qf-export-to-datatable" class="content section">
              <h2>Export to DataTable</h2>
              <p>This example shows how to use Walter to export query results to a DataTable. This code could be used in either Windows or ASP.NET to bind data to a grid or other control. Exporting to a DataTable uses Walter's default output adapter so you'll notice that no explicit output adapter instancing is required. You'll see that later with the other output adapters.</p>
              <p>The code annotation that follows provides a little more detail than the other code annotations do. It would be redundant to repeat this level of detail for each of the other output adapters. Don't let the concept of output adapters seem too mysterious. An output adapter is just a class that implements a simple interface. Output adapters get passed a DataTable by Walter's query engine and it's the output adapter's job to translate that incoming DataTable into something else. Walter's default output adapter emits a datatable&mdash;and as you can probably guess, it didn't take much code to produce this output adapter. It simply delivers the internal DataTable. More on output adapter internals later. Let's dig into how to use the default DataTable output adapter.</p> 

                <pre><code>01  Using ASNA.Helpers.DataServices
02  
03  DclFld db     Type(AdgConnection)
04  DclFld Query  Type(QueryDriver) 
05  
06  db = *New AdgConnection("*Public/IBMi") 
07  
08  Query = *New QueryDriver(db)
09  Query.Args.Inputs.Library    = "examples"
10  Query.Args.Inputs.File       = "CMastNewL2"
11  Query.Args.Inputs.FieldsList = "CMCUSTNO,CMNAME,CMSTATE"
12  Query.Args.Inputs.Rows       = 1000
13  Query.Args.Inputs.Query      = "CMSTATE = '{CMSTATE}'"
14  Query.Args.Inputs.QueryParms.Add(*New QueryField("CMSTATE",State))
15  
16  grid.DataSource = Query.Exec() *As DataTable
17
18 db.Close()</code></pre>


<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-export-to-datatable-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-export-to-datatable-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Most of Walter lives in the ASNA.Helpers.DataServices namespace. This using statement makes Walter's QueryDriver, QueryField, and QueryType objects available without needing to qualify them with their namespace.</td>
                </tr>
                <tr>
                <td>03</td>
                <td>Declare a DataGate DB connection. This is the core DB connection used by AVR's DclDB. Both DB connections participate in DataGate connection pooling and they both use the same Database Name scheme. This DB connection must be instanced before Walter's QueryDriver is instanced.</td>
                </tr>
                <tr>
                <td>04</td>
                <td>The QueryDriver is Walter's traffic cop&mdash;all of Walter's goodness flows through it.When you look at its source code, you'll see there really isn't much to the QueryDriver, it's mostly a convenience class to make it easy to stitch together the class instances that Walter needs. Most of what Walter needs is surfaced through the Query Driver. Its constructor needs to be passed an instanced (but not necessarily connected) DataGate DB connection</td>
                </tr>
                <tr>
                <td>06</td>
                <td>Instance the database connection with an ASNA DataGate database name.</td>
                </tr>
                <tr>
                <td>08</td>
                <td>The QueryDriver surfaces a layered set of classes that provides access to Walter's inputs, outputs, and error information. (In retrospect I regret aspects of this layered design and wish I had done something else. That's what I get for coding first and designing second!.) The QueryDriver receives all of its inputs through its Args.Inputs class. You'll later see that by flowing all inputs through the Args class provides another interesting way of instancing Walter (hint: if you serialize the Args.Inputs class to Json, you can easily "hydrate" an instance of Walter by via Json serialization. More on this later.) This line instance the QueryFile object which under the covers instances its Arg.Inputs class&mdash;ready to accept query inputs.</td>
                </tr>
                <tr>
                <td>09</td>
                <td>Specify the library for the query. This can be either a library name or the special value, *LIBL.</td>
                </tr>
                <tr>
                <td>10</td>
                <td>Specify the file name name for the query. Just a reminder, remember these values are specified at runtime. Unlike the tradition use of AVR's DclDiskFile, Walter has no knowledge of the file you want to use at compile time. (Note: a glaring omision in Walter surfaces itself here: Walter lacks the ability to specify a member name. Walter currently works only with the first member. This is one of the first things to add to Walter after ASNApalooza!).</td>
                </tr>
                <tr>
                <td>11</td>
                <td>Specify the fields from the file to return. This is a case-insensitive comma-separated list of field names. Each field name specified must exist in the record format. For basic uses, this list is used as it is shown here. But an alternative syntax is comma-separated list of fieldnames and column aliases. For example, in this list: "CMCUSTNO:Number, CMNAME:Name, CMADDR1:Address" the field name is provided first then a column and the field alias. The use of the field alias is adapter-specific. For example, Walter's Excel output adapter uses field aliases for column names and its Json output adapter uses field aliases to name the field in the resulting Json. Field aliases aren't used by the default DataTable output adapter. The simple delimited field list is that adapter needs. The resulting datatable will include only the field columns specified in this list. Note that even if you don't need the field in the resulting output, if a field is used in the query definition (line 13 below), it <em>must</em> be included in this list.</td>
                </tr>
                <tr>
                <td>12</td>
                <td>Specify the maximum number of rows for the query to return. A value of -1 means to return all rows that match query specs. Be careful using this option&mdash;it's probably not prudent to try to bind 100,000 rows to the ASP.NET grid or </td>
                </tr>
               <tr>
                <td>13</td>
                <td>Specify the query. This can use AND and OR statements and it specifies tokens that are replaced at runtime within braces. This parameterized query is resolved with values from the QueryParms. <em>Every</em> field in this query <em>must</em> be included in the following QueryParms collection. Note: Watch the placement of the single apostrophes carefully. This query follows open query file rules and for character values the apostrophes are necessary. As a tease, consider this: because Walter's queries are executed on the IBM i through Open Query File, advanced query facilities such as translation tables (for case insensitive searches), 'contains' searches (eg, any address with the word "Avenue" in it), range queries, and wild card queries are possible when Walter is used against the IBM i. Walter surfaces some pretty amazing, and surprising fast, query capabilities.</td>
                </tr>
                <tr>
                <td>14</td>
                <td>The QueryParms collection provides the field values for the replaceable tokens specified in the Query property. In this example, the replacement token {CMSTATE} is replaced by the value in the State variable at runtime. For example, if the State variable value is 'IN' then the query in line 14 resolves to CMSTATE = 'IN' at runtime. Each field used in the query must be represented by a corresponding field in the QueryParms collection. </td>
                </tr>
                <tr>
                <td>16</td>
                <td>Call the QueryDriver's Exec() method to execute its query. The default output adapter returns a DataTable and (because other adapters can return other types) the return value from the adapter in use <em>must</em> be cast appropriately. With Walter having produced the DataTable, you can now do anything with it you want. In many cases, it will be bound to either a Windows or ASP.NET grid control.</td>
                </tr>
                <tr>
                <td>18</td>
                <td>Close the underlying database server connection. This should always be done after you use Walter's QueryDriver's Exec() method. This connection does participate in connection pooling so there is very little overhead in reconnecting.  </td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->
                <hr>
            </div>
<!-- End: qf-export-to-datatable.html -->

<!-- Begin: qf-excel-to-file.html -->
            <div id="qf-excel-to-file" class="content section">
              <h2>Export to Excel</h2>
              <p>This example shows how to use Walter to create an Excel spreadsheet in a Windows program and save it to a local file. The next section shows how to use Walter to produce an Excel spreadsheet from an ASP.NET app. </p>
              <p>Walter's Excel output adapter uses the open source <a href="https://closedxml.codeplex.com/">ClosedXML library</a>, which provides a rational API over Microsoft's <a href="http://msdn.microsoft.com/en-us/library/office/bb448854(v=office.15).aspx">Open XML SDK for Office.</a>. I chose the ClosedXML library because it is an active project, has the features Walter needed, and has pretty good documentation. There are many alternatives for writing Excel spreadsheets in the .NET environment. If, for whatever reason, Walter's Excel output adapter doesn't suit you, write your own!</p>
              <p>Walter's default Excel output adapter accepts two meta options (through Walter's Inputs.Options collection) to specify the spreadsheet heading and the worksheet name. Through clever use of the Inputs.Options collection a scheme could probably be produced to specify to the Excel output adapter to create column and row total formulas. This has been on my todo list for months. Alas, that's why Walter is open source! Help please!</p> 
                <pre><code>01  Using ASNA.Helpers.DataServices
02  
03  DclFld db           Type(AdgConnection)
04  DclFld Query        Type(QueryDriver) 
05  DclFld ExcelAdapter Type(ToExcelAdapter)
06
07  db = *New AdgConnection("*Public/IBMi")
08  
09  Query = *New QueryDriver(db)
10  Query.Args.Inputs.Library    = "examples"
11  Query.Args.Inputs.File       = "CMastNewL2"
12  Query.Args.Inputs.FieldsList = "CMCUSTNO:Number,CMNAME:Name,+
                                    CMADDR1:Address,CMCITY:City,CMSTATE:State"
13  Query.Args.Inputs.Rows       = 1000
14  Query.Args.Inputs.Query      = "CMSTATE = '{CMSTATE}'"
15  Query.Args.Inputs.QueryParms.Add(*New QueryField("CMSTATE",State))
16
17  Query.Args.Inputs.Options.Add("heading","Customer Listing")
18  Query.Args.Inputs.Options.Add("worksheet_name","Customers")
19
20  ExcelAdapter = *New ToExcelAdapter(Query.Args) 
21  Query.OverrideAdapter(*New ToExcelAdapter(Query.Args))
22  Query.Exec() 
23  db.Close()
24  ExcelAdapter.SaveToLocalFile("c:\users\public\documents\test.xlsx")</code></pre>


<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-excel-to-file-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-excel-to-file-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Make the QueryDriver, QueryField, and QueryType objects available without needing to qualify them with their namespace.</td>
                </tr>
                <tr>
                <td>03</td>
                <td>Declare a DataGate DB connection. This is the core DB connection used by AVR's DclDB. Both DB connections participate in DataGate connection pooling and they both use the same Database Name scheme.</td>
                </tr>
                <tr>
                <td>04</td>
                <td>Declare an instance of the QueryDriver. This is Walter's core query object.</td>
                </tr>
                <tr>
                <td>05</td>
                <td>Declare an instance of the standard Excel output adapter.</td>
                </tr> 
                <tr>
                <td>07</td>
                <td>Instance the database connection.</td>
                </tr>
                <tr>
                <td>09</td>
                <td>Instance the QueryFile object.</td>
                </tr>
                <tr>
                <td>10</td>
                <td>Specify the library for the query.</td>
                </tr>
                <tr>
                <td>11</td>
                <td>Specify the file for the query.</td>
                </tr>
                <tr>
                <td>12</td>
                <td>Specify the file name name for the query. This is a comma-separated list of fields. Each field in the list can also include an alias preceded by a colon. The standard 
                 Excel output adapter uses these alias for column headings. </td>
                </tr>
                <tr>
                <td>13</td>
                <td>Specify the maximum number of rows for the query to return.</td>
                </tr>
                <tr>
                <td>14</td>
                <td>Specify that this is a simple query. This is the default query and it needs a query specified.</td>
                </tr>
                <tr>
                <td>15</td>
                <td>Specify the query. This can use AND and OR statements and it specifies tokens that are replaced at runtime. See the next line for more info.</td>
                </tr>
                <tr>
                <td>15</td>
                <td>The QueryParms collection provides the field values for the Query property. In this example, the replacement token {CMSTATE} is replaced by the value in the State variable at runtime. For example, if the State variable value is 'IN' then the query in line 14 resolves to CMSTATE = 'IN' at runtime. Each field used in the query must be represented by a corresponding field in the QueryFields collection. </td>
                </tr>
                <tr>
                <td>17</td>
                <td>Specify the spreadsheet heading. The use of the Options dictionary is specific to the output adapter. See each adapter's documentation for the options it supports.</td>
                </tr>
                <tr>
                <td>18</td>
                <td>Specify the spreadhseet worksheet name.</td>
                </tr>
                <tr>
                <td>20</td>
                <td>Instance the standard Excel output adapter.</td>
                </tr>
                <tr>
                <td>21</td>
                <td>Override the output adapter with the newly instanced Excel adapter.</td>
                </tr>
                <tr>
                <td>22</td>
                <td>Call the QueryDriver's Exec() method to execute its query. In the case of the standard Excel output adapter, nothing is returned from this method.</td>
                </tr>
                <tr>
                <td>23</td>
                <td>Use the standard Excel output adapter's SaveToLocalFile() method to save the 
                spreadsheet created.</td>
                </tr>
                <tr>
                <td>24</td>
                <td>Close the underlying database server connection. This should always be done after you use Walter's QueryFile.Exec() method. This connection does participate in connection pooling so there is very little overhead in reconnecting.  </td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->


<p>The spreadsheet produced by the code above is shown below:
<img src="public/images/spreadsheet.png" class="img-responsive">


                <hr>
            </div>
<!-- End: qf-excel-to-file.html -->

<!-- Begin: qf-export-to-listitem.html -->
            <div id="qf-export-to-listitem" class="content section">
              <h2>Export to ListItem array</h2>
              <p>This example shows how to use Walter to export query results to an array of ListItems. An array of ListItems would most usually be used to populate ASP.NET DropDownList or the Windows ComboBox.

                <pre><code>01 Using ASNA.Helpers.DataServices
02 Using System.Web.UI.WebControls 
03 ...
04 DclFld db           Type(AdgConnection)
05 DclFld Query        Type(QueryDriver) 
06 DclArray ListItems  Type(ListItem) Rank(1)
07
08 db = *New AdgConnection("*Public/IBMi")
09
10 Query = *New ASNA.Helpers.DataServices.QueryDriver(db)
11 Query.Args.Inputs.Library    = "examples
12 Query.Args.Inputs.File       = "States"
13 Query.Args.Inputs.FieldsList = "State:text,Abbrev:value"
14 Query.Args.Inputs.Rows       = 1000
15 Query.Args.Inputs.Query      = "STATE >= 'A'"
16 Query.Args.Inputs.QueryFields.Add(*New ASNA.Helpers.DataServices.QueryField("STATE",""))
17
18 Query.OverrideAdapter(*New ASNA.Helpers.DataServices.ToLisItemArrayAdapter(Query.Args)) 
19
20 ListItems = Query.Exec() *As ListItem[]
21
22 db.Close()</code></pre>

<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#qf-export-to-listitem-collapse">
          Toggle source code annotation
        </a>
      </h4>
    </div>
    <div id="qf-export-to-listitem-collapse" class="panel-collapse collapse">
      <div class="panel-body">
                <table class="table table-striped">
                <tr>
                <th>Line</th>
                <th>Description</th>
                </tr>
                <tr>
                <td>01</td>
                <td>Add the Make the QueryDriver, QueryField, and QueryType objects available without needing to qualify them with their namespace.</td>
                </tr>
                <tr>
                <td>02</td>
                <td>Make the ListItem object available to the app.</td>
                </tr>
                <tr>
                <td>04</td>
                <td>Declare a DataGate DB connection. This is the core DB connection used by AVR's DclDB. Both DB connections participate in DataGate connection pooling and they both use the same Database Name scheme.</td>
                </tr>
                <tr>
                <td>05</td>
                <td>Declare an instance of the QueryDriver. This is Walter's core query object.</td>
                </tr>
                <tr>
                <tr>
                <td>06</td>
                <td>Declare an array of ListItems. This will contain the result of Walter's query.</td>
                </tr>
                <tr>
                <td>08</td>
                <td>Instance the database connection.</td>
                </tr>
                <tr>
                <tr>
                <td>10</td>
                <td>Instance the QueryFile object.</td>
                </tr>
                <tr>
                <td>11</td>
                <td>Specify the library for the query.</td>
                </tr>
                <tr>
                <td>12</td>
                <td>Specify the file name name for the query.</td>
                </tr>
                <tr>
                <td>13</td>
                <td>Specify the fields from the file to return. The ToListItemArray output adapter requires field aliases to indicate which fields provide the text and values properties for the 
                    list item. The syntax of each field then is <FieldName>:<AliasName>.</td>
                </tr>
                <tr>
                <td>14</td>
                <td>Specify the maximum number of rows for the query to return.</td>
                </tr>
                <tr>
                <td>15</td>
                <td>Specify the query. This can use AND and OR statements and it specifies tokens that are replaced at runtime. See the next line for more info.</td>
                </tr>
                <tr>
                <td>16</td>
                <td>The QueryFields collection provides the field values for the Query property. In this example, the query is a static query&dash;that is there aren't any dynamic parameters needed for the query. However, you still need to provide a QueryField for the fields used in a static query; the value for fields used in a static query aren't used.</td>
                </tr>
                <td>18</td>
                <td>Override Walter's default output adapter with the ToListItemArray adapter. A reference isn't needed anywhere for this adapter so it is instanced inline.</td>
                </tr>
                <tr>
                <td>20</td>
                <td>Use the QueryDriver's Exec() method to execute its query, being sure to cast its result to the type returned by the output adapter.</td>
                </tr>
                <tr>
                <td>22</td>
                <td>Close the underlying database server connection. This should always be done after you use Walter's QueryFile.Exec() method. This connection does participate in connection pooling so there is very little overhead in reconnecting.</td>
                </tr>
                </table>
            </div> <!-- .panel-body -->
      </div><!-- panel-collapse collapse -->
    </div><!-- panel -->
</div><!-- panel group -->

<p>The code below shows how to use the array of ListItems to populate a Windows ComboBox. The ListItem object resides in the System.Web.UI.WebControls class. Therefore, when you use Walter to return an array of ListItems for a Windows app, be sure to add a reference to the System.Web assembly and adding a using state for System.Web.UI.WebControls.

                <pre><code>01 Using System.Web.UI.WebControls
02 ...
03 comboboxStates.Items.Clear()
04 comboboxStates.Items.AddRange(ListItems) 
05 comboboxStates.SelectedIndex = 0</code></pre> 

<p>The code above shows how to use the Windows ComboBox's AddRange() method to assign the resulting ListItemArray to the ComboBox. Similiar code is used with the ASP.NET DropDownList control.</p>
<pre><code>BegSr comboboxStates_SelectedIndexChanged Access(*Private) +
                              Event(*this.comboboxStates.SelectedIndexChanged)
    DclSrParm sender Type(*Object)
    DclSrParm e Type(System.EventArgs)

    DclFld li Type(ListItem) 

    li = comboboxStates.SelectedItem *As ListItem
    // li.value = item's value.
    // li.text =item's text.
EndSr</code></pre>

<p>Use the code above to fetch the selected ListItem from a Windows ComboBox. The selected ListItem provides the select text and value for the selected item.</p>



                <hr>
</div><!-- content section-->

<!-- End: qf-export-to-listitem.html -->

            <!-- Item #3. -->
            <div id="item3" class="content section">
              <h3>Item #3</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 4. -->
            <div id="item4" class="content section">
              <h3>Item #4</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 5. -->
            <div id="item5" class="content section">
              <h3>Item #5</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 6. -->
            <div id="item6" class="content section">
              <h3>Item #6</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 7. -->
            <div id="item7" class="content section">
              <h3>Item #7</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 8. -->
            <div id="item8" class="content section">
              <h3>Item #8</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 9. -->
            <div id="item9" class="content section">
              <h3>Item #9</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 10. -->
            <div id="item10" class="content section">
              <h3>Item #10</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 11. -->
            <div id="item11" class="content section">
              <h3>Item #11</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

            <!-- Item 12. -->
            <div id="item12" class="content section">
              <h3>Item #12</h3>
              <p>This is a section, add any HTML here. Below is an example of code block and table that can be used to describe components.</p>
            </div>

          </div><!-- /.col-sm-9 -->
        </div>

      </div> <!-- .components -->

      <div class="tab-pane" id="about">
        <h1>About</h1>
        <p class="lead">This section is for about and resources.</p>
      </div>      

    </div><!-- /.container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

    <!-- jQuery Version 1.11.0 -->
    <script src="public/vendor/jquery/dist/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="public/vendor/bootstrap/dist/js/bootstrap.min.js"></script>

<!--
    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
-->
    <script>

      /* scroll to top when clicked on navbar */
      $(".navbar > .container").on("click", function(e){
        $('html,body').animate({scrollTop:0},'slow');
      });

      /* brand logo click */
      $(".navbar-brand").on("click",function(){
        $("#home").addClass("active").siblings().removeClass("active");
        $("#tabs > li").removeClass("active");
      });

      /* make list-group selectable */
      $(".list-group>a").on("click", function(){
        $(this).addClass("active").siblings().removeClass("active");
      });

      /* auto select list-group item on scroll */
      $(document).scroll(function(){
        $('.section').each(function(){
          var position = $(document).scrollTop() - $(this).offset().top;
          if(position < 30 && position > -115) {
            $($('a[href$='+$(this).attr("id")+']')).click();
          }
        });      
      });

      /* set hash on tab select */
      $('#tabs a').click(function() {
        window.location.hash = $(this).attr("href");
        $(document).scrollTop(0);
        $(".list-group > a").removeClass("active");
      });

      $(document).ready(function(){

        if(window.location.hash !== ""){
          /* open tab based on hash value */
          if($('#tabs > li > a[href="'+window.location.hash+'"]').length){
            $('#tabs > li > a[href="'+window.location.hash+'"]').tab('show');
            setTimeout(function(){$(document).scrollTop(0)}, 200);
          }
          /* open tab and section based on hash value */
          if($('.list-group > a[href="'+window.location.hash+'"]').length){
            var tab = $('.list-group > a[href="'+window.location.hash+'"]').closest(".tab-pane").attr("id");
            $('a[href="#'+tab+'"]').tab('show');
            $('.list-group > a[href="'+window.location.hash+'"]').click();
            setTimeout(function(){$(document).scrollTop($(window.location.hash).offset().top)}, 200);
          }
        }
      });
    </script>
  </body>
</html>
